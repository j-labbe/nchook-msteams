---
phase: 03-operational-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [nchook.py]
autonomous: true

must_haves:
  truths:
    - "Sending SIGINT to the running daemon causes it to log a shutdown message, flush state to disk, and exit cleanly within 5 seconds"
    - "Sending SIGTERM to the running daemon causes it to log a shutdown message, flush state to disk, and exit cleanly within 5 seconds"
    - "Running the daemon with --dry-run prints JSON payloads to the log without making any HTTP requests"
    - "Running the daemon with --dry-run shows DRY-RUN in the startup banner"
    - "Running the daemon with --dry-run still persists state (rec_id advances)"
    - "Running the daemon without --dry-run behaves identically to before (no regression)"
  artifacts:
    - path: "nchook.py"
      provides: "_shutdown_handler function, argparse CLI parsing, dry_run threading, post-loop state flush"
      contains: "_shutdown_handler"
  key_links:
    - from: "nchook.py:_shutdown_handler"
      to: "nchook.py:running (module-level flag)"
      via: "global running; running = False"
      pattern: "def _shutdown_handler.*global running.*running = False"
    - from: "nchook.py:main()"
      to: "nchook.py:_shutdown_handler"
      via: "signal.signal() registration before event loop"
      pattern: "signal\\.signal\\(signal\\.SIG(INT|TERM)"
    - from: "nchook.py:main()"
      to: "nchook.py:run_watcher()"
      via: "dry_run=args.dry_run parameter threading"
      pattern: "run_watcher.*dry_run"
    - from: "nchook.py:run_watcher() webhook section"
      to: "nchook.py:post_webhook()"
      via: "dry_run conditional skips post_webhook, logs payload instead"
      pattern: "if dry_run.*DRY-RUN.*Would POST"
    - from: "nchook.py:run_watcher() post-loop"
      to: "nchook.py:save_state()"
      via: "Final state flush after while-running exits, before finally cleanup"
      pattern: "save_state.*state_path.*Shutdown complete"
---

<objective>
Add graceful signal handling (OPER-03) and --dry-run mode (OPER-04) to the nchook daemon.

Purpose: Make the daemon production-ready for sustained foreground operation. Graceful shutdown prevents data loss (replayed notifications) on stop. Dry-run enables safe testing of the full pipeline without hitting the webhook endpoint.

Output: Updated nchook.py with signal handlers, CLI argument parsing, dry-run conditional, and post-loop state flush.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-operational-hardening/03-RESEARCH.md
@nchook.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Graceful SIGINT/SIGTERM shutdown with post-loop state flush (OPER-03)</name>
  <files>nchook.py</files>
  <action>
Add a `_shutdown_handler(signum, frame)` function after the module-level `running = True` line (around line 46). The handler must:
- Declare `global running`
- Log: `logging.info("Received %s, initiating shutdown...", signal.Signals(signum).name)`
- Set `running = False`
- Do NOTHING else (no sys.exit, no save_state, no I/O beyond the single log call)

In `main()`, register signal handlers BEFORE the `try: run_watcher(...)` call but AFTER config loading and environment validation:
```python
signal.signal(signal.SIGINT, _shutdown_handler)
signal.signal(signal.SIGTERM, _shutdown_handler)
```

Keep the existing `except KeyboardInterrupt` in `main()` as a safety net (belt and suspenders per research).

In `run_watcher()`, add a post-loop state flush AFTER the `while running:` loop exits but BEFORE the `finally:` block. Between the end of the while loop body and the `finally:`, add:
```python
    # Graceful shutdown: flush final state
    logging.info("Saving state before exit: last_rec_id=%d", last_rec_id)
    save_state(last_rec_id, state_path)
    logging.info("Shutdown complete.")
```

This ensures that if a signal arrives mid-batch (after some notifications processed but before save_state at batch end), the high-water mark is still flushed on exit.

CRITICAL: Do NOT raise exceptions from the signal handler. Do NOT call sys.exit() from the handler. The PEP 475 auto-retry behavior means kq.control() will complete its timeout naturally and the loop exits when `while running:` re-evaluates. Shutdown taking up to 5 seconds is expected and correct.
  </action>
  <verify>
1. `python3 -c "import nchook; print('import ok')"` succeeds (no syntax errors)
2. Grep for `_shutdown_handler` in nchook.py confirms function exists
3. Grep for `signal.signal(signal.SIGINT` confirms registration
4. Grep for `signal.signal(signal.SIGTERM` confirms registration
5. Grep for `Saving state before exit` confirms post-loop flush exists
6. Grep for `except KeyboardInterrupt` confirms safety net retained
  </verify>
  <done>
_shutdown_handler sets running=False on SIGINT/SIGTERM. Signal handlers registered in main() before event loop. Post-loop save_state() call flushes state on clean shutdown. KeyboardInterrupt safety net retained.
  </done>
</task>

<task type="auto">
  <name>Task 2: --dry-run CLI flag with argparse (OPER-04)</name>
  <files>nchook.py</files>
  <action>
In `main()`, add argparse BEFORE config loading (so --help works even without config.json):
```python
parser = argparse.ArgumentParser(
    description="macOS Teams Notification Interceptor"
)
parser.add_argument(
    "--dry-run",
    action="store_true",
    help="Log webhook payloads without sending HTTP requests",
)
args = parser.parse_args()
```

Thread `dry_run` to `run_watcher()`:
- Update `run_watcher()` signature: add `dry_run=False` parameter after `config=None`
- Update the call in `main()`: `run_watcher(db_path, wal_path, STATE_FILE, config, dry_run=args.dry_run)`

In `run_watcher()`, modify the webhook delivery section (currently lines 714-721). Replace the unconditional `post_webhook()` call with a dry-run conditional:
```python
if config is not None and config.get("webhook_url"):
    msg_type = classify_notification(notif)
    payload = build_webhook_payload(notif, msg_type)
    if dry_run:
        logging.info(
            "DRY-RUN | Would POST to %s:\n%s",
            config["webhook_url"],
            json.dumps(payload, indent=2),
        )
    else:
        post_webhook(
            payload,
            config["webhook_url"],
            config.get("webhook_timeout", 10),
        )
```

Update `print_startup_summary()` to show dry-run mode:
- Add `dry_run=False` parameter to function signature
- Before the closing `logging.info("=" * 60)` line, add:
  ```python
  if dry_run:
      logging.info("  Mode:        DRY-RUN (no HTTP requests)")
  ```
- Update the call in `run_watcher()` to pass `dry_run`: `print_startup_summary(db_path, last_rec_id, config, dry_run=dry_run)`

IMPORTANT: dry-run should ONLY suppress post_webhook(). All other behavior remains: notification detection, logging, classification, payload building, state persistence. The user sees everything except actual HTTP requests.

IMPORTANT: State SHOULD still persist in dry-run mode (rec_id advances). Dry-run is about not hitting the webhook endpoint, not about replaying notifications.
  </action>
  <verify>
1. `python3 nchook.py --help` shows --dry-run flag in usage
2. `python3 nchook.py --dry-run --help` shows help (argparse before config load means --help works without config.json)
3. Grep for `dry_run` in run_watcher signature confirms parameter exists
4. Grep for `DRY-RUN` in nchook.py confirms both the webhook conditional and startup banner
5. Grep for `json.dumps(payload, indent=2)` confirms payload logging in dry-run path
6. Grep for `save_state` still called unconditionally (not gated on dry_run) confirms state persists in dry-run
  </verify>
  <done>
--dry-run flag parsed via argparse, threaded to run_watcher(). Dry-run logs full JSON payload with "DRY-RUN | Would POST" prefix instead of calling post_webhook(). Startup banner shows "Mode: DRY-RUN" when active. State persistence unaffected by dry-run. --help works without config.json.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `python3 -c "import nchook; print('ok')"` -- no import errors
2. `python3 nchook.py --help` -- shows usage with --dry-run flag
3. Verify nchook.py contains: _shutdown_handler, signal.signal(signal.SIGINT, signal.signal(signal.SIGTERM, DRY-RUN, argparse.ArgumentParser, post-loop save_state
4. Verify no regression: the `except KeyboardInterrupt` safety net in main() is preserved
5. Verify webhook delivery is the ONLY thing gated on dry_run (state persistence is unconditional)
</verification>

<success_criteria>
- _shutdown_handler function exists and sets running=False (no exceptions raised)
- SIGINT and SIGTERM handlers registered in main() before event loop entry
- Post-loop save_state() call ensures no data loss on graceful shutdown
- --dry-run flag available via argparse with --help support
- Dry-run mode logs JSON payloads instead of POST-ing them
- Startup banner shows DRY-RUN mode indicator
- State persistence works identically in both modes
- KeyboardInterrupt safety net preserved in main()
- No new external dependencies introduced
</success_criteria>

<output>
After completion, create `.planning/phases/03-operational-hardening/03-01-SUMMARY.md`
</output>
