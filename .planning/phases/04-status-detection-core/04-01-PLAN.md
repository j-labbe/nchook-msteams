---
phase: 04-status-detection-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [nchook.py]
autonomous: true

must_haves:
  truths:
    - "Running detect_user_status() when user is idle for 5+ minutes returns status=Away, source=idle, confidence=medium"
    - "Running detect_user_status() when Teams is not running returns status=Offline, source=process, confidence=high"
    - "Running detect_user_status() when user is active and Teams is running returns status=Available, source=idle, confidence=medium"
    - "Every status result dict contains detected_status, status_source, and status_confidence fields"
    - "A subprocess timeout on any signal does not crash the daemon -- the chain falls through to the next signal"
  artifacts:
    - path: "nchook.py"
      provides: "Status detection signal functions and fallback chain orchestrator"
      contains: "def detect_user_status"
  key_links:
    - from: "detect_user_status()"
      to: "_detect_idle_time()"
      via: "function call, None return triggers fallthrough"
      pattern: "_detect_idle_time\\(\\)"
    - from: "detect_user_status()"
      to: "_detect_teams_process()"
      via: "function call, used by both idle branch and standalone fallback"
      pattern: "_detect_teams_process\\(\\)"
    - from: "_detect_idle_time()"
      to: "subprocess.run ioreg"
      via: "subprocess with timeout=5"
      pattern: 'subprocess\.run.*ioreg'
    - from: "_detect_teams_process()"
      to: "subprocess.run pgrep"
      via: "subprocess with timeout=5"
      pattern: 'subprocess\.run.*pgrep'
---

<objective>
Implement the status detection foundation: three signal functions (idle time, process check, AX stub) and a fallback chain orchestrator that produces a canonical status result dict.

Purpose: Phase 4 delivers the core detection capability that Phase 5 will wire into the notification gating loop. Without this, the daemon cannot determine whether to forward or suppress notifications.
Output: Five new functions and one constant map added to nchook.py in a new "Status Detection" section.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-status-detection-core/04-RESEARCH.md
@nchook.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement signal functions and AX normalization</name>
  <files>nchook.py</files>
  <action>
Add a new "Status Detection" section in nchook.py between the "Webhook Delivery" section (after `post_webhook`, around line 598) and the "kqueue WAL Watcher" section (before `create_wal_watcher`, around line 605). Use the same section comment style as the rest of the file (`# ---------------------------------------------------------------------------`).

Implement these four functions and one constant:

1. `_detect_idle_time()` -- STAT-01:
   - Run `subprocess.run(["ioreg", "-c", "IOHIDSystem", "-d", "4"], capture_output=True, text=True, timeout=5)`
   - Check `result.returncode != 0` -> log warning, return None
   - Catch `subprocess.TimeoutExpired` -> log warning "ioreg timed out", return None
   - Catch `FileNotFoundError` -> log error "ioreg not found", return None
   - Parse with `re.search(r'"HIDIdleTime"\s*=\s*(\d+)', result.stdout)`
   - No match -> log warning, return None
   - Return `nanoseconds / 1_000_000_000` (convert ns to seconds, comment the unit)

2. `_detect_teams_process()` -- STAT-02:
   - CRITICAL: Use `pgrep -x "MSTeams"` as PRIMARY process name (not "Microsoft Teams" -- verified on this machine, see research Pitfall 1)
   - Loop over `["MSTeams", "Microsoft Teams"]` for backward compatibility
   - Run `subprocess.run(["pgrep", "-x", process_name], capture_output=True, text=True, timeout=5)`
   - `returncode == 0` -> return True (process found)
   - Catch `subprocess.TimeoutExpired` and `FileNotFoundError` -> continue to next name
   - If no name matched -> return False

3. `_detect_status_ax()` -- Placeholder for Phase 6:
   - Docstring: "Placeholder for AX status detection (Phase 6). Always returns None."
   - Body: `return None`

4. `_AX_STATUS_MAP` constant dict -- Normalization map for Phase 6:
   ```python
   _AX_STATUS_MAP = {
       "available": "Available",
       "busy": "Busy",
       "do not disturb": "DoNotDisturb",
       "in a meeting": "Busy",
       "in a call": "Busy",
       "presenting": "Busy",
       "away": "Away",
       "be right back": "BeRightBack",
       "appear offline": "Offline",
       "offline": "Offline",
       "out of office": "Offline",
   }
   ```

5. `_normalize_ax_status(raw)` -- STAT-04 prep:
   - `return _AX_STATUS_MAP.get(raw.lower().strip(), "Unknown")`

Order in file: `_detect_idle_time`, `_detect_teams_process`, `_detect_status_ax`, `_AX_STATUS_MAP`, `_normalize_ax_status`.

No new imports needed -- subprocess, re, and logging are already imported.
  </action>
  <verify>
Run `python3 -c "import nchook; print(nchook._detect_idle_time())"` -- should print a float (seconds of idle time).
Run `python3 -c "import nchook; print(nchook._detect_teams_process())"` -- should print True if Teams is running, False otherwise.
Run `python3 -c "import nchook; print(nchook._detect_status_ax())"` -- should print None.
Run `python3 -c "import nchook; print(nchook._normalize_ax_status('Do Not Disturb'))"` -- should print DoNotDisturb.
Run `python3 -c "import nchook; print(nchook._normalize_ax_status('garbage'))"` -- should print Unknown.
All commands must exit 0 with no tracebacks.
  </verify>
  <done>
Four functions and one constant exist in nchook.py. _detect_idle_time returns a float or None. _detect_teams_process returns True or False. _detect_status_ax returns None. _normalize_ax_status maps raw text to canonical values. No new imports added.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement fallback chain orchestrator</name>
  <files>nchook.py</files>
  <action>
Add `detect_user_status(config)` immediately after `_normalize_ax_status` in the Status Detection section.

Implementation (STAT-05, STAT-06, STAT-07):

```python
def detect_user_status(config):
    """
    Three-signal fallback chain producing canonical status result.

    Signal priority: AX (Phase 6) -> idle time -> process check.
    Each signal function returns a value or None. None means "try next signal."

    Returns dict with exactly three keys:
      detected_status: Available | Away | Offline | Unknown
      status_source: ax | idle | process | error
      status_confidence: high | medium | low
    """
    idle_threshold = config.get("idle_threshold_seconds", 300)

    # Signal 1: AX status text (placeholder -- always None until Phase 6)
    ax_status = _detect_status_ax()
    if ax_status is not None:
        return {
            "detected_status": _normalize_ax_status(ax_status),
            "status_source": "ax",
            "status_confidence": "high",
        }

    # Signal 2: System idle time
    idle_seconds = _detect_idle_time()
    if idle_seconds is not None:
        if idle_seconds >= idle_threshold:
            return {
                "detected_status": "Away",
                "status_source": "idle",
                "status_confidence": "medium",
            }
        # User is active (idle < threshold). Check Teams process to distinguish
        # Available (Teams running) from Offline (Teams not running).
        if _detect_teams_process():
            return {
                "detected_status": "Available",
                "status_source": "idle",
                "status_confidence": "medium",
            }
        return {
            "detected_status": "Offline",
            "status_source": "process",
            "status_confidence": "high",
        }

    # Signal 3: Process check only (idle signal failed)
    if not _detect_teams_process():
        return {
            "detected_status": "Offline",
            "status_source": "process",
            "status_confidence": "high",
        }

    # All signals failed or inconclusive -- Teams running but idle unknown
    return {
        "detected_status": "Unknown",
        "status_source": "error",
        "status_confidence": "low",
    }
```

Key rules:
- Accept `config` dict parameter. Read `idle_threshold_seconds` with default 300. This avoids a code change in Phase 5.
- The orchestrator NEVER catches exceptions from signal functions -- each signal handles its own errors and returns None.
- Every code path returns a dict with exactly three keys (STAT-07).
- When idle < threshold, ALSO check process to distinguish Available vs Offline (STAT-06).
- When idle signal fails entirely (returns None), fall back to process-only check.
- Final fallback: return Unknown/error/low when nothing worked.
  </action>
  <verify>
Run all five success criteria from the roadmap:

1. Idle user -> Away:
   `python3 -c "import nchook; r = nchook.detect_user_status({}); print(r)"` -- when idle > 5min, status=Away, source=idle, confidence=medium

2. Teams not running -> Offline:
   Quit Teams, then: `python3 -c "import nchook; r = nchook.detect_user_status({}); print(r)"` -- status=Offline, source=process, confidence=high

3. Active user + Teams running -> Available:
   With Teams running and recent keyboard/mouse activity: `python3 -c "import nchook; r = nchook.detect_user_status({}); print(r)"` -- status=Available, source=idle, confidence=medium

4. Result dict shape:
   `python3 -c "import nchook; r = nchook.detect_user_status({}); assert set(r.keys()) == {'detected_status', 'status_source', 'status_confidence'}, f'Bad keys: {r.keys()}'; print('PASS: all 3 keys present')"` -- prints PASS

5. Timeout resilience (can verify structurally -- every subprocess.run call has timeout=5, every signal function has try/except returning None):
   `python3 -c "
import nchook, ast, inspect
src = inspect.getsource(nchook._detect_idle_time)
assert 'timeout=' in src, 'Missing timeout in _detect_idle_time'
src2 = inspect.getsource(nchook._detect_teams_process)
assert 'timeout=' in src2, 'Missing timeout in _detect_teams_process'
print('PASS: all signal functions have timeout')
"`

Run `python3 -c "import nchook"` -- must exit 0 with no import errors, confirming full module integrity.
  </verify>
  <done>
detect_user_status(config) exists and satisfies all five phase success criteria: Away on idle>=300s, Offline when Teams not running, Available when active+Teams running, all results have exactly 3 keys, and all subprocess calls have timeout enforcement with None-return error handling.
  </done>
</task>

</tasks>

<verification>
Phase 4 success criteria verification:

1. `python3 -c "import nchook; r = nchook.detect_user_status({}); print(f'Status: {r}')"` -- returns valid status dict
2. `python3 -c "import nchook; r = nchook.detect_user_status({}); assert all(k in r for k in ['detected_status', 'status_source', 'status_confidence']); print('All fields present')"` -- PASS
3. `python3 -c "import nchook; r = nchook.detect_user_status({'idle_threshold_seconds': 300}); print(f'Custom threshold: {r}')"` -- config parameter accepted
4. Full module import: `python3 -c "import nchook"` -- no errors (existing functionality unbroken)
</verification>

<success_criteria>
- nchook.py contains a "Status Detection" section with 5 functions and 1 constant
- _detect_idle_time() returns float seconds or None
- _detect_teams_process() returns True/False, checks "MSTeams" first then "Microsoft Teams"
- _detect_status_ax() returns None (placeholder)
- _normalize_ax_status() maps raw text to canonical values
- detect_user_status(config) implements three-signal fallback chain
- Every result dict has exactly: detected_status, status_source, status_confidence
- No new imports added (all stdlib modules already imported)
- Existing daemon functionality unbroken (python3 nchook.py --help still works)
</success_criteria>

<output>
After completion, create `.planning/phases/04-status-detection-core/04-01-SUMMARY.md`
</output>
