---
phase: 05-config-gating-event-loop-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [nchook.py]
autonomous: true

must_haves:
  truths:
    - "When status is Away or Busy, notifications are forwarded with _detected_status, _status_source, _status_confidence in payload"
    - "When status is Available, notifications are suppressed but rec_id high-water mark still advances"
    - "When status is Unknown (all signals failed), notifications are forwarded (fail-open)"
    - "Setting status_enabled: false disables all gating -- every notification forwards as v1.0"
    - "Startup summary shows status detection enabled/disabled and current detected status"
  artifacts:
    - path: "nchook.py"
      provides: "Status gating integrated into event loop"
      contains: "_FORWARD_STATUSES"
    - path: "nchook.py"
      provides: "Gate function"
      contains: "def should_forward_status"
    - path: "nchook.py"
      provides: "Status metadata in payload"
      contains: "_detected_status"
    - path: "nchook.py"
      provides: "Config defaults for status"
      contains: "status_enabled"
    - path: "nchook.py"
      provides: "Startup status display"
      contains: "Status gate"
  key_links:
    - from: "run_watcher()"
      to: "detect_user_status()"
      via: "status_result = detect_user_status(config) called once per poll cycle"
      pattern: "detect_user_status.*config"
    - from: "run_watcher()"
      to: "should_forward_status()"
      via: "forward = should_forward_status(status_result, config)"
      pattern: "should_forward_status"
    - from: "build_webhook_payload()"
      to: "status_result dict"
      via: "status_result=None keyword arg, adds 3 metadata fields when present"
      pattern: "_detected_status.*status_result"
    - from: "run_watcher() rec_id advancement"
      to: "save_state()"
      via: "last_rec_id advances unconditionally regardless of gating decision"
      pattern: "if notifications.*last_rec_id.*save_state"
---

<objective>
Wire Phase 4's detect_user_status() into the daemon event loop to gate notification forwarding based on detected status. Add config toggle, payload metadata, and startup display.

Purpose: This is the core v1.1 feature -- suppress notifications when the user is at their desk (Available) and forward them when Away/Busy. Combined with fail-open on Unknown and a config toggle to disable gating entirely.

Output: Modified nchook.py with status-aware gating in the event loop, status metadata in webhook payloads, and startup status display.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-config-gating-event-loop-integration/05-RESEARCH.md
@.planning/phases/04-status-detection-core/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add gate function, config defaults, payload metadata, and startup display</name>
  <files>nchook.py</files>
  <action>
Four changes to nchook.py, all building blocks that Task 2 wires together:

**1. DEFAULT_CONFIG (line ~366-371):** Add two new keys to the dict:
- `"status_enabled": True` -- INTG-01 toggle for status-aware gating
- `"idle_threshold_seconds": 300` -- makes the Phase 4 config param visible in defaults

The existing `load_config()` needs NO changes -- `config.update(user_config)` already merges defaults with user overrides. Do NOT modify config.json on disk (users add `status_enabled: false` manually when desired).

**2. Gate function (after detect_user_status, ~line 747):** Add constant and function:
```python
_FORWARD_STATUSES = frozenset({"Away", "Busy", "Unknown"})

def should_forward_status(status_result, config):
```
- GATE-01: Forward on Away/Busy, suppress on Available/Offline/DoNotDisturb/BeRightBack
- GATE-02: Forward on Unknown (fail-open -- Unknown is in the frozenset)
- INTG-01: When `config.get("status_enabled", True)` is False, return True (forward everything)
- Pure function: no logging, no side effects. Takes status_result dict and config dict, returns bool.

**3. build_webhook_payload (line ~547):** Change signature from `(notif, msg_type)` to `(notif, msg_type, status_result=None)`. The `status_result=None` default preserves backward compatibility with any existing call sites.
- INTG-02: When status_result is not None, add three fields to the payload dict:
  - `"_detected_status": status_result["detected_status"]`
  - `"_status_source": status_result["status_source"]`
  - `"_status_confidence": status_result["status_confidence"]`
- When status_result IS None (status disabled), omit these fields entirely -- do NOT add them as null. This preserves exact v1.0 payload format.
- Update the docstring to mention the new parameter and INTG-02.

**4. print_startup_summary (line ~338):** After the existing `logging.info("  Log level: ...")` line (within the `if config is not None:` block), add:
- `status_enabled = config.get("status_enabled", True)`
- `logging.info("  Status gate: %s", "ENABLED" if status_enabled else "DISABLED")`
- If status_enabled, call `detect_user_status(config)` and log the result:
  `logging.info("  Current status: %s (source=%s, confidence=%s)", ...)`
- This satisfies INTG-03. The startup status check uses the same detect_user_status() as the event loop.
  </action>
  <verify>Run `python3 -c "import nchook; print('import ok')"` from the project directory to confirm no syntax errors. Then verify: (1) `grep -n "_FORWARD_STATUSES" nchook.py` finds the frozenset, (2) `grep -n "should_forward_status" nchook.py` finds the function, (3) `grep -n "status_enabled" nchook.py` finds it in DEFAULT_CONFIG, (4) `grep -n "_detected_status" nchook.py` finds it in build_webhook_payload, (5) `grep -n "Status gate" nchook.py` finds it in print_startup_summary.</verify>
  <done>Four building blocks exist in nchook.py: DEFAULT_CONFIG has status_enabled and idle_threshold_seconds, should_forward_status() is a pure gate function, build_webhook_payload() accepts and includes status metadata, print_startup_summary() shows status detection mode and current status. No syntax errors on import.</done>
</task>

<task type="auto">
  <name>Task 2: Wire status gating into run_watcher event loop</name>
  <files>nchook.py</files>
  <action>
Modify `run_watcher()` (lines ~826-891 inside the `while running:` loop) to add status-aware gating. This is the critical integration point.

**Insert status check AFTER the kqueue/poll wait block (after line ~839, before the `notifications = query_new_notifications(...)` call):**

```python
# --- Status gating (GATE-04: once per poll cycle) ---
status_enabled = config.get("status_enabled", True) if config else False
if status_enabled:
    status_result = detect_user_status(config)
    forward = should_forward_status(status_result, config)
    if not forward:
        logging.debug(
            "Status gate: suppressing (status=%s, source=%s)",
            status_result["detected_status"],
            status_result["status_source"],
        )
else:
    status_result = None
    forward = True
```

Key correctness points:
- GATE-04: Status check is OUTSIDE the `for notif in notifications` loop -- once per poll cycle, not per notification.
- When `config is None` (no config mode), status_enabled defaults to False -- preserving Phase 1 backward compat.
- When status_enabled is False, `detect_user_status()` is NOT called (no wasted subprocess overhead). status_result is None so payload won't have metadata fields.

**Modify the notification processing loop (lines ~844-885):**

After the existing filter check (`if config is not None and not passes_filter(...): continue`), add the gating check:

```python
if not forward:
    continue
```

This skips the logging, classify, build payload, and webhook POST -- but does NOT skip the rec_id advancement below.

**Modify the build_webhook_payload call (line ~873):**

Change from:
```python
payload = build_webhook_payload(notif, msg_type)
```
To:
```python
payload = build_webhook_payload(notif, msg_type, status_result)
```

This passes the status_result (or None when disabled) to include metadata in forwarded payloads.

**CRITICAL -- Do NOT touch the rec_id advancement block (lines ~887-890):**

The existing block:
```python
if notifications:
    last_rec_id = notifications[-1]["rec_id"]
    save_state(last_rec_id, state_path)
```

MUST remain OUTSIDE any `if forward:` conditional. It already is -- just verify it stays that way. This is the GATE-03 compliance point: rec_id always advances even when gating suppresses forwarding.

**Add batch suppression summary at INFO level:**

After the `for notif in notifications:` loop ends but BEFORE the rec_id advancement block, if `not forward` and `notifications` has items, log a summary:
```python
if not forward and notifications:
    suppressed = sum(1 for n in notifications if config is None or passes_filter(n, config))
    if suppressed:
        logging.info(
            "Status gate: suppressed %d notification(s) (status=%s)",
            suppressed, status_result["detected_status"],
        )
```
This provides operational visibility at INFO level without logging each suppressed notification individually (those are at DEBUG via the existing filter log).

Note: The suppressed count may differ from len(notifications) because some notifications may have been filtered by passes_filter() anyway. Count only those that WOULD have been forwarded.
  </action>
  <verify>Run `python3 -c "import nchook; print('import ok')"` to confirm no syntax errors. Then verify the critical structural requirements: (1) `grep -n "detect_user_status" nchook.py` shows the call in run_watcher BEFORE query_new_notifications, (2) `grep -n "should_forward_status" nchook.py` shows the call in run_watcher, (3) `grep -n "if not forward" nchook.py` shows the gating check inside the notification loop, (4) `grep -n "save_state" nchook.py` confirms save_state is NOT inside any `if forward:` block -- it must be unconditional, (5) `grep -n "status_result" nchook.py` shows it passed to build_webhook_payload. Run `python3 nchook.py --dry-run 2>&1 | head -20` to confirm startup banner includes "Status gate: ENABLED" and "Current status:" lines (will fail on webhook_url but status lines should appear before that).</verify>
  <done>run_watcher() calls detect_user_status() once per poll cycle (GATE-04), gates forwarding via should_forward_status() (GATE-01/02), passes status_result to build_webhook_payload() (INTG-02), and the rec_id advancement block remains unconditional (GATE-03). Startup banner shows status detection mode. All 7 requirements (GATE-01 through GATE-04, INTG-01 through INTG-03) are implemented.</done>
</task>

</tasks>

<verification>
After both tasks complete, verify all 7 requirements:

1. **GATE-01 (Forward Away/Busy, suppress rest):** `grep "_FORWARD_STATUSES" nchook.py` shows `frozenset({"Away", "Busy", "Unknown"})`. Any status NOT in the set is suppressed.
2. **GATE-02 (Fail-open on Unknown):** "Unknown" is in `_FORWARD_STATUSES`.
3. **GATE-03 (rec_id always advances):** `save_state` call is at the same indentation as the `for notif` loop (outside it), not inside `if forward`.
4. **GATE-04 (Once per cycle):** `detect_user_status(config)` is called inside `while running:` but outside `for notif in notifications:`.
5. **INTG-01 (Config toggle):** `status_enabled` in DEFAULT_CONFIG with True default. `should_forward_status()` returns True when disabled.
6. **INTG-02 (Payload metadata):** `build_webhook_payload` signature includes `status_result=None`, adds 3 `_`-prefixed fields when present.
7. **INTG-03 (Startup display):** `print_startup_summary` shows "Status gate: ENABLED/DISABLED" and current status when enabled.

Run: `python3 -c "import nchook; print('OK')"` -- must succeed with no errors.
</verification>

<success_criteria>
- nchook.py imports cleanly with no syntax errors
- should_forward_status() exists as a pure function
- _FORWARD_STATUSES contains exactly {"Away", "Busy", "Unknown"}
- build_webhook_payload accepts status_result=None and conditionally adds 3 metadata fields
- print_startup_summary shows status gate mode and current status
- run_watcher event loop checks status once per cycle, gates forwarding, always advances rec_id
- All 7 requirements (GATE-01-04, INTG-01-03) are implemented
</success_criteria>

<output>
After completion, create `.planning/phases/05-config-gating-event-loop-integration/05-01-SUMMARY.md`
</output>
