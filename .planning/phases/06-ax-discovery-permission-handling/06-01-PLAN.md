---
phase: 06-ax-discovery-permission-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [nchook.py]
autonomous: true

must_haves:
  truths:
    - "With AX permission granted and Teams running, detect_user_status() returns the actual Teams status with source=ax and confidence=high"
    - "Raw AX status text (e.g., 'Be Right Back', 'Do not disturb') is normalized to canonical values (BeRightBack, DoNotDisturb, etc.)"
    - "Without AX permission, startup logs actionable instructions naming the correct terminal application"
    - "When AX signal fails or permission is denied, the daemon silently falls back to idle+process detection without user intervention"
  artifacts:
    - path: "nchook.py"
      provides: "_check_ax_permission() via ctypes AXIsProcessTrusted"
      contains: "AXIsProcessTrusted"
    - path: "nchook.py"
      provides: "_detect_status_ax() real implementation replacing placeholder"
      contains: "osascript"
    - path: "nchook.py"
      provides: "_get_terminal_app_name() for actionable instructions"
      contains: "TERM_PROGRAM"
    - path: "nchook.py"
      provides: "Module-level _ax_available cache"
      contains: "_ax_available"
  key_links:
    - from: "_detect_status_ax()"
      to: "_check_ax_permission()"
      via: "permission gate before osascript"
      pattern: "_ax_available"
    - from: "_detect_status_ax()"
      to: "detect_user_status()"
      via: "existing fallback chain (returns raw string or None)"
      pattern: "ax_status = _detect_status_ax"
    - from: "print_startup_summary()"
      to: "_check_ax_permission()"
      via: "AX status display and actionable instructions"
      pattern: "_check_ax_permission|_get_terminal_app_name"
    - from: "_detect_status_ax()"
      to: "_normalize_ax_status()"
      via: "existing normalization in detect_user_status fallback chain"
      pattern: "_normalize_ax_status\\(ax_status\\)"
---

<objective>
Implement AX permission probing, Teams status reading via AppleScript, actionable permission instructions, and graceful degradation -- completing the final signal in the three-signal fallback chain.

Purpose: This is the last phase of v1.1. It replaces the _detect_status_ax() placeholder with a real implementation that reads Teams status from the macOS Accessibility tree when permission is granted, and degrades silently to idle+process detection when it is not. The AX tree for new Teams (com.microsoft.teams2) is known to be broken for external callers, so the phase is designed to succeed regardless of AX viability.

Output: Modified nchook.py with working AX permission probe, AppleScript status query, startup AX instructions, and self-disabling safety net.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ax-discovery-permission-handling/06-RESEARCH.md
@.planning/phases/04-status-detection-core/04-01-SUMMARY.md
@nchook.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: AX permission probe, terminal detection, and startup instructions</name>
  <files>nchook.py</files>
  <action>
Add `import ctypes` to the import block at the top of nchook.py (after `import re`).

Add the following functions and module-level state in the "Status Detection" section of nchook.py, BEFORE the existing `_detect_idle_time()` function:

1. **`_check_ax_permission()` function** -- Uses ctypes to call `AXIsProcessTrusted()` from the ApplicationServices framework. Loads the framework at `/System/Library/Frameworks/ApplicationServices.framework/ApplicationServices` via `ctypes.cdll.LoadLibrary()`. Sets `restype = ctypes.c_bool` and `argtypes = []`. Returns True if permission granted, False on any error (including OSError, AttributeError). This is a pure probe with no side effects.

2. **Module-level `_ax_available` variable** -- Initialized to None. Set once at first access or at startup. This caches the AX permission result for the process lifetime because macOS requires a process restart for TCC permission changes to take effect on a running process.

3. **Module-level `_ax_consecutive_failures` variable** -- Initialized to 0. Counts consecutive AX query failures. Used by Task 2's safety net.

4. **`_AX_MAX_FAILURES` constant** -- Set to 3. After this many consecutive osascript failures, AX self-disables for the session.

5. **`_get_terminal_app_name()` function** -- Reads `os.environ.get("TERM_PROGRAM", "")`. Maps known values to user-friendly names: "Apple_Terminal" -> "Terminal.app", "iTerm.app" -> "iTerm2", "Alacritty" -> "Alacritty", "WezTerm" -> "WezTerm", "WarpTerminal" -> "Warp", "vscode" -> "Visual Studio Code", "tmux" -> "your terminal application (tmux session host)". Returns the mapped name or the raw value or "your terminal application" as fallback.

6. **Modify `print_startup_summary()`** -- After the existing status display block (lines 357-366, the `if status_enabled:` block that shows current status), add AX permission status:
   - Call `_check_ax_permission()` and cache result in the module-level `_ax_available` variable (so _detect_status_ax in Task 2 can use it without re-calling).
   - If AX permission is granted: log `"  AX status:   AVAILABLE (Accessibility permission granted)"`
   - If AX permission is NOT granted: log `"  AX status:   NOT AVAILABLE (Accessibility permission not granted)"`, then log actionable instructions:
     ```
     "  To enable AX-based status detection:"
     "    1. Open System Settings > Privacy & Security > Accessibility"
     "    2. Click the + button and add: {app_name}"
     "    3. Restart the daemon"
     "  Without AX, status detection falls back to idle+process signals."
     ```
     where `{app_name}` comes from `_get_terminal_app_name()`.
   - The AX status lines should appear INSIDE the `if status_enabled:` block, after the current status line, because AX status is only relevant when status detection is enabled.

IMPORTANT: Do NOT modify `_detect_status_ax()` in this task -- that is Task 2. Do NOT modify `detect_user_status()` or `should_forward_status()` -- those already handle AX correctly via the fallback chain.

IMPORTANT: The `_ax_available` variable must be set during `print_startup_summary()` so it is cached before the event loop starts calling `_detect_status_ax()`.
  </action>
  <verify>
Run `python3 -c "import nchook"` to verify no import errors.

Run `python3 -c "from nchook import _check_ax_permission; print(_check_ax_permission())"` -- should print True or False without error.

Run `python3 -c "from nchook import _get_terminal_app_name; print(_get_terminal_app_name())"` -- should print a terminal name string.

Verify that `_ax_available`, `_ax_consecutive_failures`, and `_AX_MAX_FAILURES` are defined at module level.

Verify the import block includes `import ctypes`.
  </verify>
  <done>
_check_ax_permission() returns a boolean via AXIsProcessTrusted ctypes call. _get_terminal_app_name() returns a user-friendly terminal name. print_startup_summary() displays AX permission status and actionable instructions when permission is not granted. _ax_available is cached at startup for use by _detect_status_ax().
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace AX status detection placeholder with real implementation and safety net</name>
  <files>nchook.py</files>
  <action>
Replace the existing `_detect_status_ax()` placeholder (lines 687-689: returns None unconditionally) with a real implementation:

```python
def _detect_status_ax():
    """
    STAT-03: Read Teams status text from Accessibility tree via osascript.

    Returns raw status text string (e.g., "Busy", "Away") or None on failure.
    None causes the fallback chain in detect_user_status() to proceed to
    idle+process signals. Never raises exceptions.

    Permission gate: skips osascript entirely if AX permission not granted
    (cached at startup via _ax_available).

    Safety net: after _AX_MAX_FAILURES consecutive failures, self-disables
    for the remainder of the session to avoid wasting 3s per poll cycle on
    a broken AX tree.
    """
    global _ax_available, _ax_consecutive_failures

    # Fast path: AX not available (permission denied or self-disabled)
    if _ax_available is None:
        _ax_available = _check_ax_permission()
    if not _ax_available:
        return None

    # AppleScript to read Teams status via System Events.
    # Tries two candidate paths:
    # 1. Menu bar item description (Teams menu bar extension, late 2024+)
    # 2. First static text of the main window (legacy fallback)
    # The script returns the first non-empty result or empty string.
    script = '''
try
    tell application "System Events"
        tell process "MSTeams"
            -- Candidate 1: Menu bar extension status (most promising for new Teams)
            try
                set statusText to description of menu bar item 1 of menu bar 2
                if statusText is not "" and statusText is not missing value then
                    return statusText
                end if
            end try
            -- Candidate 2: Window title or status area
            try
                set statusText to value of static text 1 of group 1 of group 1 of window 1
                if statusText is not "" and statusText is not missing value then
                    return statusText
                end if
            end try
        end tell
    end tell
    return ""
on error errMsg number errNum
    return ""
end try
'''

    try:
        result = subprocess.run(
            ['osascript', '-e', script],
            capture_output=True,
            text=True,
            timeout=3,  # Must be < poll_interval (5s) to avoid blocking event loop
        )
        if result.returncode != 0:
            logging.debug("AX query error (exit %d): %s",
                         result.returncode, result.stderr.strip())
            _ax_consecutive_failures += 1
            if _ax_consecutive_failures >= _AX_MAX_FAILURES:
                logging.info(
                    "AX query failed %d consecutive times; disabling AX for this session. "
                    "Falling back to idle+process signals.",
                    _ax_consecutive_failures,
                )
                _ax_available = False
            return None

        raw = result.stdout.strip()
        if not raw:
            _ax_consecutive_failures += 1
            if _ax_consecutive_failures >= _AX_MAX_FAILURES:
                logging.info(
                    "AX query returned empty %d consecutive times; disabling AX for this session. "
                    "Falling back to idle+process signals.",
                    _ax_consecutive_failures,
                )
                _ax_available = False
            return None

        # Success -- reset failure counter and return raw text
        _ax_consecutive_failures = 0
        return raw

    except subprocess.TimeoutExpired:
        logging.debug("AX query timed out (3s)")
        _ax_consecutive_failures += 1
        if _ax_consecutive_failures >= _AX_MAX_FAILURES:
            logging.info(
                "AX query timed out %d consecutive times; disabling AX for this session. "
                "Falling back to idle+process signals.",
                _ax_consecutive_failures,
            )
            _ax_available = False
        return None
    except FileNotFoundError:
        logging.debug("osascript not found")
        _ax_available = False  # Permanent: no osascript means no AX ever
        return None
```

Key implementation details:
- The AppleScript uses a try/on error wrapper to catch all AppleScript-level errors and return empty string (not crash).
- Two candidate AX paths are tried in order: menu bar extension (most promising per research) then window static text. This avoids `entire contents` which would traverse the entire AX tree.
- The 3s timeout is strictly less than the 5s poll interval to prevent event loop blocking.
- The consecutive failure counter is per-session (resets to 0 on success). After 3 failures, `_ax_available` is set to False, permanently skipping AX for this process.
- `FileNotFoundError` (osascript not found) permanently disables AX.
- The function returns the raw status text string -- normalization is handled by the existing `_normalize_ax_status()` call in `detect_user_status()`.

Do NOT modify `detect_user_status()` -- it already calls `_detect_status_ax()` and handles the return value correctly (non-None -> normalize and return with source=ax, confidence=high; None -> fall through to idle signal).

Do NOT modify `_AX_STATUS_MAP` or `_normalize_ax_status()` -- they already handle the expected status text variants. Unknown values map to "Unknown" which triggers fail-open forwarding per GATE-02.
  </action>
  <verify>
Run `python3 -c "import nchook"` to verify no import errors.

Run `python3 -c "from nchook import _detect_status_ax; result = _detect_status_ax(); print(f'AX result: {result!r}')"` -- should print either a status string (if AX permission granted and Teams running) or None (if permission denied or Teams not running). Must not raise an exception.

Run `python3 -c "from nchook import detect_user_status; r = detect_user_status({'idle_threshold_seconds': 300}); print(r)"` -- should return a valid status dict. If AX works, source will be 'ax' and confidence 'high'. If not, falls through to idle/process.

Verify the function handles all failure modes without exceptions:
- `python3 -c "from nchook import _detect_status_ax, _check_ax_permission; print('AX permission:', _check_ax_permission()); print('AX detect:', _detect_status_ax())"` must complete without error.

Verify `_ax_consecutive_failures` and `_AX_MAX_FAILURES` are used correctly by inspecting the function body.
  </verify>
  <done>
_detect_status_ax() is a real implementation that reads Teams status via AppleScript with a 3s timeout, gated by the _ax_available permission cache. Returns raw status text on success or None on any failure. Self-disables after 3 consecutive failures. The existing fallback chain in detect_user_status() handles both success and failure paths without modification. All four requirements are satisfied: STAT-03 (AX reading), STAT-04 (normalization via existing _normalize_ax_status), INTG-04 (permission probe + instructions from Task 1), INTG-05 (graceful degradation via None return + self-disable safety net).
  </done>
</task>

</tasks>

<verification>
**Requirement coverage:**

- STAT-03 (AX tree reading): Task 2 -- _detect_status_ax() reads Teams status via osascript AppleScript
- STAT-04 (Normalization): Already implemented (_AX_STATUS_MAP + _normalize_ax_status). Verified by detect_user_status() calling _normalize_ax_status(ax_status) when _detect_status_ax() returns non-None
- INTG-04 (Permission probe + instructions): Task 1 -- _check_ax_permission() via ctypes, startup instructions with terminal app name
- INTG-05 (Graceful degradation): Task 1 (permission cache) + Task 2 (None return on failure, self-disable safety net)

**Integration verification:**

1. `python3 -c "from nchook import detect_user_status; print(detect_user_status({'idle_threshold_seconds': 300}))"` -- Full fallback chain works end-to-end
2. `python3 -c "from nchook import _check_ax_permission; print(_check_ax_permission())"` -- Permission probe returns boolean
3. `python3 -c "from nchook import _normalize_ax_status; print(_normalize_ax_status('Do not disturb'))"` -- Should print "DoNotDisturb"
4. `python3 -c "from nchook import _normalize_ax_status; print(_normalize_ax_status('Be Right Back'))"` -- Should print "BeRightBack"

**Edge cases:**
- AX permission denied: _detect_status_ax() returns None immediately (no osascript call), startup logs instructions
- Teams not running: AppleScript returns empty string, function returns None, chain falls through
- AX tree broken: osascript returns empty/error, after 3 failures AX self-disables for session
- osascript not found: Permanent AX disable, returns None
</verification>

<success_criteria>
1. With AX permission granted and Teams running: detect_user_status() returns status with source=ax and confidence=high (or falls through if AX tree is broken, which is an expected outcome)
2. _normalize_ax_status() converts raw AX text to canonical values (already verified working from Phase 4)
3. Without AX permission: startup banner shows "AX status: NOT AVAILABLE" with instructions naming the correct terminal app
4. When AX fails: daemon continues with idle+process detection silently -- no crashes, no user intervention needed
5. After 3 consecutive AX failures: AX self-disables for the session with a single INFO log line
6. No new external dependencies added (ctypes is stdlib)
</success_criteria>

<output>
After completion, create `.planning/phases/06-ax-discovery-permission-handling/06-01-SUMMARY.md`
</output>
